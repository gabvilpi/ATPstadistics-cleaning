---
title: "Práctica 2: Limpieza y validación de los datos"
author: "Alejandro Manuel Olivares Luque y Gabriel Villalba Pintado"
date: '`r format(Sys.Date(),"%e de %B, %Y")`'
output:
  html_document:
    toc: yes
    toc_depth: 4
  pdf_document:
    toc: yes
    toc_depth: 4
---

# Práctica 2: Limpieza y validación de los datos

## 1. Descripción del dataset

Por qué es importante y qué pregunta/problema pretende responder.

La ATP organiza diferentes torneos en una misma temporada, que abarca de Enero a Noviembre. Los torneos se clasifican según la puntuación que el ganador recibe en cada uno de ellos:

- ATP 250
- ATP 500
- ATP 1000
- Grand Slam (2000)

Por lo tanto, los ganadores se embolsan desde 250 puntos en el primero torneo hasta los 2000 de un Grand Slam. Esta puntuación se utiliza para realizar la clasificación de los tenistas en el ranking mundial. Los tenistas con mejor ranking disponen de plazas directas para jugar los torneos, mientras que el resto tendrá que jugar un mini torneo para poder acceder a ellos.

Además de la puntuación, los torneos difieren en la cantidad de tenistas que participan en ellos, diferencia que va desde los 28 tenistas que disputan un ATP 250 hasta los 128 de un Grand Slam.

El dataset "ATPStatistics" utilizado para esta práctica, es un set de datos sobre la competición ATP World Tour que se ha obtenido mediante un proyecto de web Scraping de la página http://www.atpworldtour.com/ desarrollado por Alejandro Manuel Olivares Luque.

En dicho proyecto se ha realizado la extracción de datos, estadísticas y resultados de los partidos oficiales organizados por Asociación de Tenistas Profesionales (ATP).

El desarrollo del scrapper se ha realizado mediante el lenguaje Python y haciendo uso de librerías adicionales como urllib2, beautifulsoup y xlwt. Todo el código se encuentra disponible en Github en el siguiente enlace: https://github.com/olivaresluque/scrapATP

El resultado obtenido se ha almacenado en fichero de Microsoft Excel en formato xls. En él se ha volcado la información relativa a los partidos comprendidos entre el año 2011 y la actualidad, lo que representa algo más de 30.000 registros. Para cada registro se dispone de los siguientes atributos:

- id_partido: Código identificador únido del partido
- Player 1: Nombre del jugador 1 del partido
- Player 2: Nombre del jugador 2 del partido
- Serve Rating 1: Puntuación oficial del saque para el jugador 1
- Serve Rating 2: Puntuación oficial del saque para el jugador 2
- Aces 1: Cantidad de ACEs del jugador 1 en el partido	
- Aces 2:  Cantidad de ACEs del jugador 2 en el partido
- Double Faults 1: Número de faltas dobles del jugador 1 en el partido
- Double Faults 2: Número de faltas dobles del jugador 2 en el partido
- % 1st Serve 1: Porcentaje de servicios correctos en el primer servicio para el jugador 1
- % 1st Serve 2: Porcentaje de servicios correctos en el primer servicio para el jugador 2
- % 1st Serve Won 1: Porcentaje de puntos ganados con el primer servicio para el jugador 1
- % 1st Serve Won 2: Porcentaje de puntos ganados con el primer servicio para el jugador 2
- % 2nd Serve Won 1: Porcentaje de puntos ganados con el segundo servicio para el jugador 1
- % 2nd Serve Won 2: : Porcentaje de puntos ganados con el segundo servicio para el jugador 2
- % Break Point Saved 1: Porcentaje de puntos de break salvados por el jugador 1
- % Break Point Saved 2: Porcentaje de puntos de break salvados por el jugador 2
- Served Games Played 1: Número de juegos en los que ha tenido servicio el jugador 1
- Served Games Played 2: Número de juegos en los que ha tenido servicio el jugador 2
- Return Rating 1: Puntuación oficial de resto para el jugador 1
- Return Rating 2: Puntuación oficial de resto para el jugador 2
- % 1st Serve Return Won 1: Porcentaje de puntos ganados restando el primer servicio por el jugador 1
- % 1st Serve Return Won 2: Porcentaje de puntos ganados restando el primer servicio por el jugador 2	
- % 2nd Serve Return Won 1: Porcentaje de puntos ganados restando el segundo servicio por el jugador 1
- % 2nd Serve Return Won 2: Porcentaje de puntos ganados restando el segundo servicio por el jugador 2
- % Break Point Converted 1: Porcentaje de puntos de break convertidos por el jugador 1
- % Break Point Converted 2: Porcentaje de puntos de break convertidos por el jugador 2
- Return Games Played 1: Número de juegos en los que ha restado el jugador 1
- Return Games Played 2: Número de juegos en los que ha restado el jugador 2
- % Served Point Won 1: Porcentaje de puntos ganados con su servicio para el jugador 1
- % Served Point Won 2: Porcentaje de puntos ganados con su servicio para el jugador 2
- % Return Point Won 1: Porcentaje de puntos ganados con su resto para el jugador 1
- % Return Point Won 2: Porcentaje de puntos ganados con su resto para el jugador 2
- % Total Point Won 1: Porcentaje total de puntos ganados por el jugador 1
- % Total Point Won 2: Porcentaje total de puntos ganados por el jugador 2
- Winner: Nombre del ganador del partido
- Tournament: Nombre del torneo
- Started date: Fecha de inicio del torneo
- Ended date: Fecha de fin del torneo
- Surface: Superficie del torneo

La extracción de estos datos tiene como objetivo crear un almacén de datos con el que realizar un estudio estadístico y construir un modelo de clasificación que permita predecir el ganador de nuevos partidos o torneos.

## 2. Integración y selección de los datos de interés a analizar

En primer lugar realizamos la carga del dataset ATPStatistics y mostramos sus primeras lineas para revisar que se ha realizado correctamente.

```{r chunck1}
library(readxl)
ATPstatistics <- read_excel("../Data/ATPstatistics.xlsx")
head(ATPstatistics)
```

Una vez cargado el set de datos procedemos a realizar un estudio de la estructura de los diferentes atributos para ver que tipo le ha asignado R a cada uno de ellos.

```{r chunck2}
str(ATPstatistics)
```

Como podemos observar, R no ha asignado el tipo de dato correcto o más adeacudo a los atributos. Por lo tanto, a continuación realizaremos una conversión del tipo de dato para cada uno de los atributos. También aprovechamos para transformar los datos que indican un porcentaje. Por último volvemos a mostrar la estructura del set de datos para observar los cambios realizados en los atributos.

```{r chunck3}
ATPstatistics$id_partido<-as.integer(ATPstatistics$id_partido)
ATPstatistics$`Player 1`<-as.factor(ATPstatistics$`Player 1`)
ATPstatistics$`Player 2`<-as.factor(ATPstatistics$`Player 2`)
ATPstatistics$`Serve Rating 1` <- as.integer(ATPstatistics$`Serve Rating 1`)
ATPstatistics$`Serve Rating 2` <- as.integer(ATPstatistics$`Serve Rating 2`)
ATPstatistics$`Aces 1`<- as.integer(ATPstatistics$`Aces 1`)
ATPstatistics$`Aces 2`<- as.integer(ATPstatistics$`Aces 2`)
ATPstatistics$`Double Faults 1` <- as.integer(ATPstatistics$`Double Faults 1`)
ATPstatistics$`Double Faults 2` <- as.integer(ATPstatistics$`Double Faults 2`)
ATPstatistics$`Served Games Played 1` <- as.integer(ATPstatistics$`Served Games Played 1`)
ATPstatistics$`Served Games Played 2` <- as.integer(ATPstatistics$`Served Games Played 2`)
ATPstatistics$`Return Rating 1` <- as.integer(ATPstatistics$`Return Rating 1`)
ATPstatistics$`Return Rating 2` <- as.integer(ATPstatistics$`Return Rating 2`)
ATPstatistics$`Return Games Played 1` <- as.integer(ATPstatistics$`Return Games Played 1`)
ATPstatistics$`Return Games Played 2` <- as.integer(ATPstatistics$`Return Games Played 2`)
ATPstatistics$Winner <- as.factor(ATPstatistics$Winner)
ATPstatistics$Tournament <- as.factor(ATPstatistics$Tournament)
ATPstatistics$`Started date` <- as.Date(as.character(ATPstatistics$`Started date`), "%d/%m/%Y")
ATPstatistics$`Ended date` <- as.Date(as.character(ATPstatistics$`Ended date`),  "%d/%m/%Y")
ATPstatistics$Surface <- as.factor(ATPstatistics$Surface)
ATPstatistics$`% 1st Serve 1` <- as.double(ATPstatistics$`% 1st Serve 1`)/100
ATPstatistics$`% 1st Serve 2` <- as.double(ATPstatistics$`% 1st Serve 2`)/100
ATPstatistics$`% 1st Serve Won 1` <-as.double(ATPstatistics$`% 1st Serve Won 1`)/100
ATPstatistics$`% 1st Serve Won 2` <-as.double(ATPstatistics$`% 1st Serve Won 2`)/100
ATPstatistics$`% 2nd Serve Won 1` <-as.double(ATPstatistics$`% 2nd Serve Won 1`)/100
ATPstatistics$`% 2nd Serve Won 2` <-as.double(ATPstatistics$`% 2nd Serve Won 2`)/100
ATPstatistics$`% Break Point Saved 1` <- as.double(ATPstatistics$`% Break Point Saved 1`)/100
ATPstatistics$`% Break Point Saved 2` <- as.double(ATPstatistics$`% Break Point Saved 2`)/100
ATPstatistics$`% Served Point Won 1` <- as.double(ATPstatistics$`% Served Point Won 1`)/100
ATPstatistics$`% Served Point Won 2` <- as.double(ATPstatistics$`% Served Point Won 2`)/100
ATPstatistics$`% Return Point Won 1` <- as.double(ATPstatistics$`% Return Point Won 1`)/100
ATPstatistics$`% Return Point Won 2` <- as.double(ATPstatistics$`% Return Point Won 2`)/100
ATPstatistics$`% Total Point Won 1` <- as.double(ATPstatistics$`% Total Point Won 1`)/100
ATPstatistics$`% Total Point Won 2` <- as.double(ATPstatistics$`% Total Point Won 2`)/100
ATPstatistics$`% 1st Serve Return Won 1` <- as.double(ATPstatistics$`% 1st Serve Return Won 1`)/100
ATPstatistics$`% 1st Serve Return Won 2` <- as.double(ATPstatistics$`% 1st Serve Return Won 2` )/100
ATPstatistics$`% 2nd Serve Return Won 1`<- as.double(ATPstatistics$`% 2nd Serve Return Won 1`)/100
ATPstatistics$`% 2nd Serve Return Won 2`<- as.double(ATPstatistics$`% 2nd Serve Return Won 2`)/100
ATPstatistics$`% Break Point Converted 1`<- as.double(ATPstatistics$`% Break Point Converted 1`)/100
ATPstatistics$`% Break Point Converted 2`<- as.double(ATPstatistics$`% Break Point Converted 2`)/100
str(ATPstatistics)
```

## 3. Limpieza de los datos.

### 3.1. Datos a cero o elementos vacíos

El primer paso a realizar en la limpieza de datos es analizar si los atirbutos contienen datos nulos o vacíos. Para ello haremos uso de la función summary de R.

```{r chunck5}
summary(ATPstatistics)
```

Como podemos obaservar, existen atributos con datos a cero, algunos de estos atributos no pueden ser 0 y si lo son es por que no se han recogido datos para ese partido, por ejemplo 'Served Games Played'. Estas observaciones carecen de interés estadístico y debemos eliminarlas para que no alteren los modelos que construyamos a partir de los datos.

A continuación borramos las observaciones que no han recogido datos de ese partido.

```{r chunck6}
# Modificar por el atributo 'Served games played'?
ATPstatistics<- ATPstatistics[which(ATPstatistics$`Serve Rating 1`!=0 & ATPstatistics$`Serve Rating 2`!=0 & ATPstatistics$`Return Rating 1` !=0 & ATPstatistics$`Return Rating 2` !=0),]
```

### 3.2 Identificación y tratamiento de valores extremos

El segundo paso en la tarea de limpiar los datos es identificar y tratar los valores extrremos. Para ver fácilmente si los atributos del dataset cuentan con valores extremos, haremos uso de unos diagramas de caja. En el caso de los atributos contengan valores extremos, estos estarán representados por un círculo.

```{r chunck8}
boxplot(ATPstatistics$`Serve Rating 1`,notch=TRUE, main= ("Serve Rating player 1"))
boxplot(ATPstatistics$`Serve Rating 2`,notch=TRUE, main= ("Serve Rating player 2"))
boxplot(ATPstatistics$`Aces 1`,notch=TRUE, main= ("Aces player 1"))
boxplot(ATPstatistics$`Aces 2`,notch=TRUE, main= ("Aces player 2"))
boxplot(ATPstatistics$`Double Faults 1`,notch=TRUE, main= ("Double Faults player 1"))
boxplot(ATPstatistics$`Double Faults 2`,notch=TRUE, main= ("Double Faults player 2"))
boxplot(ATPstatistics$`Return Rating 1`,notch=TRUE, main= ("Return rating player 1"))
boxplot(ATPstatistics$`Return Rating 2`,notch=TRUE, main= ("Return rating player 2"))
boxplot(ATPstatistics$`% 1st Serve 1`,notch=TRUE, main= ("% 1st Serve player 1"))
boxplot(ATPstatistics$`% 1st Serve 2`,notch=TRUE, main= ("% 1st Serve player 2"))
boxplot(ATPstatistics$`% 1st Serve Won 1`,notch=TRUE, main= ("% 1st Serve Won player 1"))
boxplot(ATPstatistics$`% 1st Serve Won 2`,notch=TRUE, main= ("% 1st Serve Won player 2"))
boxplot(ATPstatistics$`% 2nd Serve Won 1`,notch=TRUE, main= ("% 2nd Serve Won player 1"))
boxplot(ATPstatistics$`% 2nd Serve Won 2`,notch=TRUE, main= ("% 2nd Serve Won player 2"))
boxplot(ATPstatistics$`% Break Point Saved 1`,notch=TRUE, main= ("% Break point saved player 1"))
boxplot(ATPstatistics$`% Break Point Saved 2`,notch=TRUE, main= ("% Break poiint saved player 2"))
boxplot(ATPstatistics$`% 1st Serve Return Won 1`,notch=TRUE, main= ("% 1st Serve Return Won player 1"))
boxplot(ATPstatistics$`% 1st Serve Return Won 2`,notch=TRUE, main= ("% 1st Serve Return Won player 2"))
boxplot(ATPstatistics$`% 2nd Serve Return Won 1`,notch=TRUE, main= ("% 2nd Serve Return Won player 1"))
boxplot(ATPstatistics$`% 2nd Serve Return Won 2`,notch=TRUE, main= ("% 2nd Serve Return Won player 2"))
boxplot(ATPstatistics$`% Served Point Won 1`,notch=TRUE, main= ("% Served Point Won player 1"))
boxplot(ATPstatistics$`% Served Point Won 2`,notch=TRUE, main= ("% Served Point Won player 2"))
boxplot(ATPstatistics$`% Return Point Won 1`,notch=TRUE, main= ("% Return Point Won player 1"))
boxplot(ATPstatistics$`% Return Point Won 2`,notch=TRUE, main= ("% Return Point Won player 2"))
boxplot(ATPstatistics$`% Total Point Won 1`,notch=TRUE, main= ("Total Point Won player 1"))
boxplot(ATPstatistics$`% Total Point Won 2`,notch=TRUE, main= ("Total Point Won player 2"))
```

Como podemos observar en los diagramas de caja, existen bastantes valores extremos. Nosotros hemos decidido mantener estos valores ya que, por un lado, confiamos en la fuente de datos (ya que es una fuenta oficial) y por otro lado, es normal que haya jugadores que se salgan de lo normal, no hace falta irse muy lejos para saber que hay jugadores que tienen unas estadisticas que marcan una historia, como por ejemplo Roger Federer y Rafael Nadal.

## 4. Análisis de los datos

### 4.1. Selección de datos a analizar / comparar

Selección de los grupos de datos que se quieren analizar/comparar(planificación de los análisis a aplicar).

Quitaremos el número total de juegos al servicio y al resto, ya que a priori, no nos aporta información relativa al juego de cada jugador.

```{r chunck4}
ATPstatistics<-ATPstatistics[-c(18:19)]
ATPstatistics<-ATPstatistics[-c(26:27)]
```

### 4.2. Análisis de la varianza

Comprobación de la normalidad y homogeneidad de la varianza.

Realizamos un test de normalidad y homogeneidad a los datos

```{r chunck9}
'
#NO FUNCIONA
library(nortest)
atributos_no_normales = c()
for(i in 4:(ncol(ATPstatistics)-5)){
  atributos_no_normales = c(atributos_no_normales,colnames(ATPstatistics[ad.test(as.matrix(ATPstatistics[,i]))$p.value < 0.05]))
}
'

#Añadir homogeneidad
```

### 4.3. Pruebas estadísticas de los datos

Aplicación de pruebas estadísticas para comparar los grupos de datos. En funci?n de los datos y el objetivo del estudio, aplicar pruebas de contrastede hipótesis, correlaciones, regresiones, etc.

```{r chunck11}

```

## 5. Representación gráfica de los datos

Representación de los resultados a partir de tablas y gráficas.

```{r chunck12}

```

## 6. Resolución del problema

A partir de los resultados obtenidos, ?cu?les son las conclusiones? ?Los resultados permiten responder al problema?

Para poder responder a la pregunta que nos planteabamos al inicio, dado que los datos no están del todo preparados, ya que tenemos las estadisticas reales de los partidos. Necesitamos obtener las estimaciones de los partidos, para ello, realizaremos la media y varianza de las estadisticas de los últimos partidos de cada jugador.

```{r chunck7}
require(data.table)
partidos = 5
dataset <- matrix(nrow=0,ncol=63)
variablesj1 <- c(1,seq(4,31,by = 2))
variablesj2 <- c(1,seq(5,32,by = 2))
otras_variables <- seq(33,ncol(ATPstatistics),by = 1)
jugador1<-as.character(ATPstatistics$`Player 1`)
jugador2<-as.character(ATPstatistics$`Player 2`)
for(i in 1:nrow(ATPstatistics)){
  resultado <- matrix(nrow=0,ncol=63)
  estadisticas_jugador1_1 <-ATPstatistics[which(ATPstatistics$`Player 1`==jugador1[i]),variablesj1]
  estadisticas_jugador1_2 <-ATPstatistics[which(ATPstatistics$`Player 2`==jugador1[i]),variablesj2]
  estadisticas_jugador2_1 <-ATPstatistics[which(ATPstatistics$`Player 1`==jugador2[i]),variablesj1]
  estadisticas_jugador2_2 <-ATPstatistics[which(ATPstatistics$`Player 2`==jugador2[i]),variablesj2] 
  estadisticas_jugador1 <- rbind(as.matrix(estadisticas_jugador1_1),as.matrix(estadisticas_jugador1_2))
  estadisticas_jugador2 <- rbind(as.matrix(estadisticas_jugador2_2),as.matrix(estadisticas_jugador2_1))
  estadisticas_jugador1<-data.table(estadisticas_jugador1,key="id_partido")
  estadisticas_jugador2<-data.table(estadisticas_jugador2,key="id_partido")
  estadisticas_jugador1 <- estadisticas_jugador1[(which(estadisticas_jugador2$id_partido >ATPstatistics$id_partido[i])),2:ncol(estadisticas_jugador1)]
  estadisticas_jugador2 <- estadisticas_jugador2[(which(estadisticas_jugador2$id_partido > ATPstatistics$id_partido[i])),2:ncol(estadisticas_jugador2)]
  if(nrow(estadisticas_jugador1)>= partidos & nrow(estadisticas_jugador2)>= partidos){
    estadisticas_jugador1 <- estadisticas_jugador1[1:partidos,]
    estadisticas_jugador2 <- estadisticas_jugador2[1:partidos,]
    estadisticas_jugador1 <- cbind(t(colMeans(estadisticas_jugador1)),t(apply(estadisticas_jugador1,2,sd)))
    estadisticas_jugador2 <- cbind(t(colMeans(estadisticas_jugador2)),t(apply(estadisticas_jugador2,2,sd)))
    if(i%%2 == 1){
      if(ATPstatistics$Winner[i]==jugador1[i])
        ganador = 1
      else
        ganador = 2
      resultado <- cbind(ATPstatistics$id_partido[i],jugador1[i],jugador2[i],estadisticas_jugador1,estadisticas_jugador2,ganador,ATPstatistics[i,otras_variables])
    }
    else{
      if(ATPstatistics$Winner[i]==jugador1[i])
        ganador = 2
      else
        ganador = 1
      resultado <- cbind(ATPstatistics$id_partido[i],jugador2[i],jugador1[i],estadisticas_jugador2,estadisticas_jugador1,ganador,ATPstatistics[i,otras_variables])
    }
    if(i == 1)
      dataset<-resultado
    else
      dataset <- rbind(as.matrix(dataset),as.matrix(resultado))
  }
}
#write.csv(dataset, "./Data/dataset.csv")
```

Una vez tenemos generado el dataset, procedemos a realizar un kfold de 10 y procedemos a entrenar los diferentes modelos.

```{r chunck10}


```

Como podemos ver en en los resultados de los diferentes modelos obtenemos un acierto de X en test, por lo que afirmamos que con los datos que hemos obtenido podemos realizar predicciones de los partidos futuros. 